<!DOCTYPE html>
<html>
 <head>
  <title></title>
  <script src="jsUnitCore.js"></script>
  <script src="socket.js"></script>
  <script src="../client/base64.js"></script>
  <script src="../client/des.js"></script>
  <script src="../client/rfb.js"></script>
 </head>
 <body>
  <script>	
	function createProtocol(option) {
		return RFB(option);
	}
	
	function receive(protocol, messages) {
		for(var i = 0; i < messages.length; i++) protocol.receive(messages[i]);			
	}
	
	function e(clear) { return Base64.encode(clear);}
	
	function toAscii(data) {
		var ascii = [];
		for (var i = 0; i < data.length; i++) ascii[i] = String.fromCharCode(data[i]);
		return ascii.join('');
	}
	
			
    //handshaking and protocol selection
	function testShouldHandshakingAndChooseProtocol() {
		var protocolVersions = {
			"RFB 003.003\n" : [3.3, "RFB 003.003\n"],
			"RFB 003.005\n" : [3.3, "RFB 003.003\n"],
			"RFB 003.007\n" : [3.7, "RFB 003.007\n"],
			"RFB 003.008\n" : [3.8, "RFB 003.008\n"],
			"RFB 003.899\n" : [3.8, "RFB 003.008\n"]
		}		
		for(var message in protocolVersions) {
			var socket = createSocket();
			var rfb = createProtocol({socket: socket});			
			rfb.receive(Base64.encode(message));
			assertEquals(protocolVersions[message][1], socket.messages().pop());
			assertEquals(protocolVersions[message][0], rfb.protocol.version);						
		}
	}
	
	function testShouldAlwaysUseAVersonIfSpecified() {
		var protocolVersions = {
			"RFB 003.003\n" : [3.3, "RFB 003.003\n"],
			"RFB 003.005\n" : [3.3, "RFB 003.003\n"],
			"RFB 003.007\n" : [3.3, "RFB 003.003\n"],
			"RFB 003.008\n" : [3.3, "RFB 003.003\n"],
			"RFB 003.899\n" : [3.3, "RFB 003.003\n"]
		}		
		for(var message in protocolVersions) {
			var socket = createSocket();
			var rfb = createProtocol({socket: socket, password: 'password', always : 3.3});
			rfb.receive(e(message));
			assertEquals(protocolVersions[message][1], socket.messages().pop());
			assertEquals(protocolVersions[message][0], rfb.protocol.version);						
		}		
	}	
	
	function testShouldWaitForChallengeIfSecurityIs2For33() {
		var socket = createSocket();
		var rfb = createProtocol({socket: socket, password: 'password'});
		receive(rfb, [e("RFB 003.003\n"), e([0, 0, 0, 2]), e([50,238,122,229,104,197,181,62,77,31,203,112,196,63,213,111])]);
		assertEquals(toAscii(DES.encrypt('password', [50,238,122,229,104,197,181,62,77,31,203,112,196,63,213,111])), socket.messages().pop());
	}	
	
	function testShouldSendClientInitIfAuthOk() {
		var socket = createSocket();
		var rfb = createProtocol({socket: socket, password: 'password'});
		receive(rfb, [e("RFB 003.003\n"), e([0, 0, 0, 2]), e([50,238,122,229,104,197,181,62,77,31,203,112,196,63,213,111]), e([0, 0, 0, 0])]);
		assertEquals('\1', socket.messages().pop());		
	}
	
	function testShouldCallCanvasInitAccrodingToServerInit() {
		// var serverInit = { 
		//   "BaADhCAgAAEA/wD/AP8QCAAAAAAAAAAYVmluY2VudCBYdSdzIE1hY0Jvb2sgUHJv" : 	{width: 1440, height: 900}
		// }
		// 
		var _name, _width, _height, _format;
		var socket = createSocket();
		var rfb = createProtocol({socket: socket, password: 'password', client: {onServerInit: function(name, width, height, pixelFormat) {_name = name, _width = width, _height = height, _format = pixelFormat;}}});		
		receive(rfb, [e("RFB 003.003\n"), e([0, 0, 0, 2]), e([50,238,122,229,104,197,181,62,77,31,203,112,196,63,213,111]), e([0, 0, 0, 0]), "BaADhCAgAAEA/wD/AP8QCAAAAAAAAAAYVmluY2VudCBYdSdzIE1hY0Jvb2sgUHJv"]);
		assertEquals("Vincent Xu's MacBook Pro", _name);
		assertEquals(1440, _width);
		assertEquals(900, _height);	
		assertEquals(32, _format.bitsPerPixel);
		assertEquals(32, _format.depth);
		assertEquals(false, _format.bigEndian);
		assertEquals(true, _format.trueColor);
		assertEquals(255, _format.redMax);
		assertEquals(255, _format.greenMax);	
		assertEquals(255, _format.blueMax);	
		assertEquals(16, _format.redShift);
		assertEquals(8, _format.greenShift);	
		assertEquals(0, _format.blueShift);			
	}
	
	function testShouldCallCanvasInitAccrodingToServerInit2() {
		var _name, _width, _height, _format;
		var socket = createSocket();
		var rfb = createProtocol({socket: socket, password: 'password', client: {onServerInit: function(name, width, height, pixelFormat) {_name = name, _width = width, _height = height, _format = pixelFormat;}}});		
		receive(rfb, [e("RFB 003.003\n"), e([0, 0, 0, 2]), e([50,238,122,229,104,197,181,62,77,31,203,112,196,63,213,111]), e([0, 0, 0, 0]), "BQAEABAQAAEAHwA/AB8LBQAAAAAAAAAbaXAtMTAtMjI4LTEzOS0yMDoxICh1YnVudHUp"]);
		assertEquals("ip-10-228-139-20:1 (ubuntu)", _name);
		assertEquals(1280, _width);
		assertEquals(1024, _height);	
		assertEquals(16, _format.bitsPerPixel);
		assertEquals(16, _format.depth);
		assertEquals(false, _format.bigEndian);
		assertEquals(true, _format.trueColor);
		assertEquals(31, _format.redMax);
		assertEquals(63, _format.greenMax);	
		assertEquals(31, _format.blueMax);	
		assertEquals(11, _format.redShift);
		assertEquals(5, _format.greenShift);	
		assertEquals(0, _format.blueShift);			
	}	
	
	
	function testShouldWaitAllContentForSingleRectangleFramebufferUpdate() {
		var rectangle = {}, _x, _y;
		var socket = createSocket();
		var rfb = createProtocol({socket: socket, password: 'password', client: {onServerInit: function(name, width, height, pixelFormat) {},createRectangle : function(width, height) { rectangle.data = new Array(width * height * 4); return rectangle;}, drawRectangle: function(x, y, rectangle) { _x = x; _y = y}}});
		receive(rfb, [e("RFB 003.003\n"), e([0, 0, 0, 2]), e([50,238,122,229,104,197,181,62,77,31,203,112,196,63,213,111]), e([0, 0, 0, 0]), "BaADhCAgAAEA/wD/AP8QCAAAAAAAAAAYVmluY2VudCBYdSdzIE1hY0Jvb2sgUHJv", e([0,0,0,1, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0,0]), e([1,1,1,1,1,1,1,1]), e([1,1,1,1,1,1,1,1])]);
		assertEquals(16, rectangle.data.length);
		assertEquals([1,1,1,255,1,1,1,255,1,1,1,255,1,1,1,255].join(':'), rectangle.data.join(':'));
	}
	
	function testShouldContiuneHandleFramebufferUpdate() {
		var rectangle = {}, _x, _y;
		var socket = createSocket();
		var rfb = createProtocol({socket: socket, password: 'password', client: {onServerInit: function(name, width, height, pixelFormat) {},createRectangle : function(width, height) { rectangle.data = new Array(width * height * 4); return rectangle;}, drawRectangle: function(x, y, rectangle) { _x = x; _y = y}}});
		receive(rfb, [e("RFB 003.003\n"), e([0, 0, 0, 2]), e([50,238,122,229,104,197,181,62,77,31,203,112,196,63,213,111]), e([0, 0, 0, 0]), "BaADhCAgAAEA/wD/AP8QCAAAAAAAAAAYVmluY2VudCBYdSdzIE1hY0Jvb2sgUHJv", e([0,0,0,1, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0,0]), e([1,1,1,1,1,1,1,1]), e([1,1,1,1,1,1,1,1]), e([0,0,0,1, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0,0]), e([2,2,2,2,2,2,2,2]), e([2,2,2,2,2,2,2,2])]);
		assertEquals(16, rectangle.data.length);
		assertEquals([2,2,2,255,2,2,2,255,2,2,2,255,2,2,2,255].join(':'), rectangle.data.join(':'));		
	}
	
	function testShouldContiuneHandleFramebufferUpdateIfServerThenTogether() {
		var rectangle = {}, _x, _y;
		var socket = createSocket();
		var rfb = createProtocol({socket: socket, password: 'password', client: {onServerInit: function(name, width, height, pixelFormat) {},createRectangle : function(width, height) { rectangle.data = new Array(width * height * 4); return rectangle;}, drawRectangle: function(x, y, rectangle) { _x = x; _y = y}}});
		receive(rfb, [e("RFB 003.003\n"), e([0, 0, 0, 2]), e([50,238,122,229,104,197,181,62,77,31,203,112,196,63,213,111]), e([0, 0, 0, 0]), "BaADhCAgAAEA/wD/AP8QCAAAAAAAAAAYVmluY2VudCBYdSdzIE1hY0Jvb2sgUHJv", e([0,0,0,1, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0,0]), e([1,1,1,1,1,1,1,1]), e([1,1,1,1,1,1,1,1, 0,0,0,1, 0, 0, 0, 0, 0, 2, 0, 2, 0, 0, 0,0]), e([2,2,2,2,2,2,2,2]), e([2,2,2,2,2,2,2,2])]);
		assertEquals(16, rectangle.data.length);
		assertEquals([2,2,2,255,2,2,2,255,2,2,2,255,2,2,2,255].join(':'), rectangle.data.join(':'));		
	}
	
	function testShouldSendSetEncodingsRequest() {
		var rectangle = {}, _x, _y;
		var socket = createSocket();
		var rfb = createProtocol({socket: socket, password: 'password', client: {onServerInit: function(name, width, height, pixelFormat) {},createRectangle : function(width, height) { rectangle.data = new Array(width * height * 4); return rectangle;}, drawRectangle: function(x, y, rectangle) { _x = x; _y = y}}});
		receive(rfb, [e("RFB 003.003\n")]);
		rfb.protocol.setEncodings();
		assertEquals(toAscii([2, 0, 0, 2, 0, 0, 0, 1, 0, 0, 0, 0]), socket.messages().pop());
	}
  </script>
 </body>
</html>